---
layout:     post
title:      "死锁和解决方案"
subtitle:   "死锁和解决方案"
date:       2020-04-12
author:     "Lerko"
header-img: "/q8mq1hi36.bkt.clouddn.com/blog/20200412182752.png"
catalog: true
multilingual: true
tags:
    - 锁
---

## 死锁的定义

**多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进**

## 为什么会死锁

下图是一个死锁的实例示例:

![20200412192943](http://q8mq1hi36.bkt.clouddn.com/blog/20200412192943.png)

**死锁发生的必要条件:**

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。


其实那个图已经非常清楚了,就是资源处理的时候还互相想要占用对方的锁.


## 如何防止解决死锁

### 锁不能进行剥夺

**锁不能强制剥夺**

### 请求与保持条件

**尽量再资源处理的开头获取全部的锁,并且在结束的时候释放锁**

![20200412193505](http://q8mq1hi36.bkt.clouddn.com/blog/20200412193505.png)


### 不能有循环等待的条件

**不能锁等待时间过长,应该有一个等待的最大值**

![20200412193708](http://q8mq1hi36.bkt.clouddn.com/blog/20200412193708.png)