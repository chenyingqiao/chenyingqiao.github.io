---
layout:     post
title:      "死锁和解决方案"
subtitle:   "死锁和解决方案"
date:       2020-04-12
author:     "Lerko"
header-img: "http://img.chenyingqiao.top/blog/20200412182752.png"
catalog: true
multilingual: false
tags:
    - 锁
---

## 死锁的定义

**多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进**

## 为什么会死锁

下图是一个死锁的实例示例:

![20200412192943](http://img.chenyingqiao.top/blog/20200412192943.png)

> 下面是一段golang的goroutine的死锁实例,因为相互还想争夺锁导致deadlock。
> 但是这种deadlock是语言本身检查不出来的，需要开发者自己进行排查处理，不然会导致两个goroutine僵死


```golang
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	deadLock2()
}

func deadLock2() {
	a, b := 0, 0
	var lockA, lockB sync.Mutex

	// 当goroutine1和goroutine2互相尝试获取对方锁这个时候就造成了deadlock

	go func() {
		for {
			fmt.Println("goroutian1 begin")
			lockA.Lock()
			time.Sleep(100 * time.Microsecond)
			a++
			lockB.Lock() //尝试获取b的锁
			b++
			lockB.Unlock()
			lockA.Unlock()
			fmt.Println("goroutian1", a, b)
		}
	}()

	go func() {
		for {
			fmt.Println("goroutian2 begin")
			lockB.Lock()
			time.Sleep(100 * time.Microsecond)
			b++
			lockA.Lock() //尝试获取A的锁
			a++
			lockA.Unlock()
			lockB.Unlock()
			fmt.Println("goroutian2", a, b)
		}
	}()

	time.Sleep(10 * time.Second) //不管这里等待多久goroutine都不会进行输入
	fmt.Println(a, b)            //最后主goroutine不在进行等待直接输出a b
}

```

**死锁发生的必要条件:**

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。


其实那个图已经非常清楚了,就是资源处理的时候还互相想要占用对方的锁.


## 如何防止解决死锁

### 锁不能进行剥夺

**锁不能强制剥夺**

### 请求与保持条件

**尽量再资源处理的开头获取全部的锁,并且在结束的时候释放锁**

![20200412193505](http://img.chenyingqiao.top/blog/20200412193505.png)


### 不能有循环等待的条件

**不能锁等待时间过长,应该有一个等待的最大值**

![20200412193708](http://img.chenyingqiao.top/blog/20200412193708.png)


## 银行家算法

银行家算法是一个避免死锁的算法
核心思想是:提前预估需求,资源足够才进行资源配置.