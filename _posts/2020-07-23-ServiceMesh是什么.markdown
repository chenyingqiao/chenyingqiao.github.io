---
layout:     post
title:      "ServiceMesh是什么"
subtitle:   "ServiceMesh是什么"
date:       2020-07-23
author:     "Lerko"
header-img: "/img/post-bg-e2e-ux.jpg"
catalog: true
multilingual: false
tags:
    - K8S
    - 分布式
    - Istio
---


# 微服务的演化


![20200727101334](http://img.chenyingqiao.top/blog/20200727101334.png)

我们可以看到当服务数量大大增加的时候，我们将不易于管理和查看微服务系统是否正常

下面是几种微服务的模式

1. **传统集中式代理**

![20200727101620](http://img.chenyingqiao.top/blog/20200727101620.png)

通过运维治理，这种方式通常在DNS域名服务器的配合下实现服务发现。

2. **客户端嵌入式代理**

![20200727101819](http://img.chenyingqiao.top/blog/20200727101819.png)

这是很多互联网公司比较流行的一种做法，代理(包括服务发现和负载均衡逻辑)以客户库的形式嵌入在应用程序中。这种模式一般需要独立的服务注册中心组件配合，服务启动时自动注册到注册中心并定期报心跳，客户端代理则发现服务并做负载均衡。

Netflix开源的Eureka(注册中心)[附录1]和Ribbon(客户端代理)[附录2]是这种模式的典型案例，国内阿里开源的Dubbo也是采用这种模式。

3. **主机独立进程代理**

![20200727103222](http://img.chenyingqiao.top/blog/20200727103222.png)


各种方式的优缺点

![20200727103302](http://img.chenyingqiao.top/blog/20200727103302.png)


# ServiceMesh

所谓的ServiceMesh，其实本质上就是上面提到的模式三~主机独立进程模式，这个模式其实并不新鲜，业界(国外的Airbnb和国内的唯品会等)早有实践，那么为什么现在这个概念又流行起来了呢？我认为主要原因如下：

上述模式一和二有一些固有缺陷，模式一相对比较重，有单点问题和性能问题；模式二则有客户端复杂，支持多语言困难，无法集中治理的问题。模式三是模式一和二的折中，弥补了两者的不足，它是纯分布式的，没有单点问题，性能也OK，应用语言栈无关，可以集中治理。

微服务化、多语言和容器化发展的趋势，企业迫切需要一种轻量级的服务发现机制，ServiceMesh正是迎合这种趋势诞生，当然这还和一些大厂(如Google/IBM等)的背后推动有关。

模式三(ServiceMesh)也被形象称为边车(Sidecar)模式，如下图，早期有一些摩托车，除了主驾驶位，还带一个边车位，可以额外坐一个人。在模式三中，业务代码进程(相当于主驾驶)共享一个代理(相当于边车)，代理除了负责服务发现和负载均衡，还负责动态路由、容错限流、监控度量和安全日志等功能，这些功能是具体业务无关的，属于跨横切面关注点(Cross-Cutting Concerns)范畴。

![20200727103456](http://img.chenyingqiao.top/blog/20200727103456.png)

在新一代的ServiceMesh架构中(下图上方)，服务的消费方和提供方主机(或者容器)两边都会部署代理SideCar。ServiceMesh比较正式的术语也叫数据面板(DataPlane)，与数据面板对应的还有一个独立部署的控制面板(ControlPlane)，用来集中配置和管理数据面板，也可以对接各种服务发现机制(如K8S服务发现)。术语数据面板和控制面板，估计是偏网络SDN背景的人提出来的。

![20200727103724](http://img.chenyingqiao.top/blog/20200727103724.png)


上图左下角，每个主机上同时居住了业务逻辑代码(绿色表示)和代理(蓝色表示)，服务之间通过代理发现和调用目标服务，形成服务之间的一种网络状依赖关系，控制面板则可以配置这种依赖调用关系，也可以调拨路由流量。如果我们把主机和业务逻辑剥离，就出现一种网格状架构(上图右下角)，服务网格由此得名。

# 参考

https://www.jianshu.com/p/27a742e349f7


